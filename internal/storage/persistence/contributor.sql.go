// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: contributor.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createContributor = `-- name: CreateContributor :one
insert into contributor as c (id, full_name)
values ($1, $2)
on conflict do nothing
returning c.id
`

type CreateContributorParams struct {
	ID       uuid.UUID `db:"id" json:"id"`
	FullName string    `db:"full_name" json:"full_name"`
}

func (q *Queries) CreateContributor(ctx context.Context, arg CreateContributorParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createContributor, arg.ID, arg.FullName)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getAllContributors = `-- name: GetAllContributors :many
select id, is_verified, full_name, verified_at, created_at, updated_at, deleted_at, email, scores from contributor_account_scores as cas
`

func (q *Queries) GetAllContributors(ctx context.Context) ([]ContributorAccountScore, error) {
	rows, err := q.db.Query(ctx, getAllContributors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContributorAccountScore{}
	for rows.Next() {
		var i ContributorAccountScore
		if err := rows.Scan(
			&i.ID,
			&i.IsVerified,
			&i.FullName,
			&i.VerifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Email,
			&i.Scores,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContributorById = `-- name: GetContributorById :one
select id, is_verified, full_name, verified_at, created_at, updated_at, deleted_at, email, scores from contributor_account_scores as cas
where cas.id = $1
`

func (q *Queries) GetContributorById(ctx context.Context, id uuid.UUID) (ContributorAccountScore, error) {
	row := q.db.QueryRow(ctx, getContributorById, id)
	var i ContributorAccountScore
	err := row.Scan(
		&i.ID,
		&i.IsVerified,
		&i.FullName,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.Scores,
	)
	return i, err
}

const getUnverifiedContributors = `-- name: GetUnverifiedContributors :many
select id, is_verified, full_name, verified_at, created_at, updated_at, deleted_at from contributor as c
where c.is_verified = false
`

func (q *Queries) GetUnverifiedContributors(ctx context.Context) ([]Contributor, error) {
	rows, err := q.db.Query(ctx, getUnverifiedContributors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contributor{}
	for rows.Next() {
		var i Contributor
		if err := rows.Scan(
			&i.ID,
			&i.IsVerified,
			&i.FullName,
			&i.VerifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const verifyContributor = `-- name: VerifyContributor :exec
update contributor
set is_verified = true,
    verified_at = now()
where id = $1
`

func (q *Queries) VerifyContributor(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, verifyContributor, id)
	return err
}
