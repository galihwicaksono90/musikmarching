// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: contributor.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createContributor = `-- name: CreateContributor :one
insert into contributor as c (
  id, 
  full_name,
  phone_number,
  musical_background,
  education,
  experience,
  portofolio_link
) values (
  $1, 
  $2,
  $3,
  $4,
  education = COALESCE($5, education),
  experience = COALESCE($6, experience),
  portofolio_link = COALESCE($7, portofolio_link)
)
on conflict do nothing
returning c.id
`

type CreateContributorParams struct {
	ID                uuid.UUID   `db:"id" json:"id"`
	FullName          string      `db:"full_name" json:"full_name"`
	PhoneNumber       string      `db:"phone_number" json:"phone_number"`
	MusicalBackground string      `db:"musical_background" json:"musical_background"`
	Education         pgtype.Text `db:"education" json:"education"`
	Experience        pgtype.Text `db:"experience" json:"experience"`
	PortofolioLink    pgtype.Text `db:"portofolio_link" json:"portofolio_link"`
}

func (q *Queries) CreateContributor(ctx context.Context, arg CreateContributorParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createContributor,
		arg.ID,
		arg.FullName,
		arg.PhoneNumber,
		arg.MusicalBackground,
		arg.Education,
		arg.Experience,
		arg.PortofolioLink,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getAllContributors = `-- name: GetAllContributors :many
select id, is_verified, full_name, verified_at, phone_number, musical_background, education, experience, portofolio_link, created_at, updated_at, deleted_at, email, scores from contributor_account_scores as cas
`

func (q *Queries) GetAllContributors(ctx context.Context) ([]ContributorAccountScore, error) {
	rows, err := q.db.Query(ctx, getAllContributors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContributorAccountScore{}
	for rows.Next() {
		var i ContributorAccountScore
		if err := rows.Scan(
			&i.ID,
			&i.IsVerified,
			&i.FullName,
			&i.VerifiedAt,
			&i.PhoneNumber,
			&i.MusicalBackground,
			&i.Education,
			&i.Experience,
			&i.PortofolioLink,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Email,
			&i.Scores,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContributorBestSellingScores = `-- name: GetContributorBestSellingScores :many
select s.id, s.title, count(p.score_id) as count, sum(py.revenue) as revenue 
from purchase p
inner join score s on p.score_id = s.id
inner join payment py on py.purchase_id = p.id
where s.contributor_id = $1::uuid
group by p.score_id, s.id
order by count desc
limit 5
`

type GetContributorBestSellingScoresRow struct {
	ID      uuid.UUID `db:"id" json:"id"`
	Title   string    `db:"title" json:"title"`
	Count   int64     `db:"count" json:"count"`
	Revenue int64     `db:"revenue" json:"revenue"`
}

func (q *Queries) GetContributorBestSellingScores(ctx context.Context, contributorID uuid.UUID) ([]GetContributorBestSellingScoresRow, error) {
	rows, err := q.db.Query(ctx, getContributorBestSellingScores, contributorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContributorBestSellingScoresRow{}
	for rows.Next() {
		var i GetContributorBestSellingScoresRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Count,
			&i.Revenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContributorById = `-- name: GetContributorById :one
select id, is_verified, full_name, verified_at, phone_number, musical_background, education, experience, portofolio_link, created_at, updated_at, deleted_at, email, scores from contributor_account_scores as cas
where cas.id = $1
`

func (q *Queries) GetContributorById(ctx context.Context, id uuid.UUID) (ContributorAccountScore, error) {
	row := q.db.QueryRow(ctx, getContributorById, id)
	var i ContributorAccountScore
	err := row.Scan(
		&i.ID,
		&i.IsVerified,
		&i.FullName,
		&i.VerifiedAt,
		&i.PhoneNumber,
		&i.MusicalBackground,
		&i.Education,
		&i.Experience,
		&i.PortofolioLink,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.Scores,
	)
	return i, err
}

const getContributorPaymentMethod = `-- name: GetContributorPaymentMethod :one
select p.id, p.method, p.bank_name, p.account_number, p.contributor_id, p.created_at, p.updated_at, p.deleted_at from payment_method p
inner join contributor c on p.contributor_id = c.id
where c.id = $1::uuid
limit 1
`

func (q *Queries) GetContributorPaymentMethod(ctx context.Context, contributorID uuid.UUID) (PaymentMethod, error) {
	row := q.db.QueryRow(ctx, getContributorPaymentMethod, contributorID)
	var i PaymentMethod
	err := row.Scan(
		&i.ID,
		&i.Method,
		&i.BankName,
		&i.AccountNumber,
		&i.ContributorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getContributorPaymentStatistics = `-- name: GetContributorPaymentStatistics :one
select 
    sum(py.revenue) as total_paid,
    (
      select py.verified_at from payment py
      inner join purchase pu on py.purchase_id = pu.id
      inner join score s on s.id = pu.score_id
      where pu.is_verified = true
      and s.contributor_id = $1::uuid
      order by py.verified_at desc
      limit 1
    ) as latest_payment
from payment py
inner join purchase pu on py.purchase_id = pu.id
inner join score s on pu.score_id = s.id
and s.contributor_id = $1::uuid
`

type GetContributorPaymentStatisticsRow struct {
	TotalPaid     int64              `db:"total_paid" json:"total_paid"`
	LatestPayment pgtype.Timestamptz `db:"latest_payment" json:"latest_payment"`
}

func (q *Queries) GetContributorPaymentStatistics(ctx context.Context, contributorID uuid.UUID) (GetContributorPaymentStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getContributorPaymentStatistics, contributorID)
	var i GetContributorPaymentStatisticsRow
	err := row.Scan(&i.TotalPaid, &i.LatestPayment)
	return i, err
}

const getContributorPayments = `-- name: GetContributorPayments :many
select 
  py.id, 
  py.purchase_id, 
  py.price, 
  py.revenue, 
  py.created_at, 
  py.is_verified,
  py.payment_method,
  py.account_number,
  py.bank_name,
  pu.invoice_serial, 
  c.id as contributor_id,
  s.title  
from payment py
inner join purchase pu on py.purchase_id = pu.id
inner join score s on s.id = pu.score_id
inner join contributor c on c.id = s.contributor_id
where c.id = $1::uuid
`

type GetContributorPaymentsRow struct {
	ID            uuid.UUID      `db:"id" json:"id"`
	PurchaseID    uuid.UUID      `db:"purchase_id" json:"purchase_id"`
	Price         pgtype.Numeric `db:"price" json:"price"`
	Revenue       pgtype.Numeric `db:"revenue" json:"revenue"`
	CreatedAt     time.Time      `db:"created_at" json:"created_at"`
	IsVerified    bool           `db:"is_verified" json:"is_verified"`
	PaymentMethod pgtype.Text    `db:"payment_method" json:"payment_method"`
	AccountNumber pgtype.Text    `db:"account_number" json:"account_number"`
	BankName      pgtype.Text    `db:"bank_name" json:"bank_name"`
	InvoiceSerial int32          `db:"invoice_serial" json:"invoice_serial"`
	ContributorID uuid.UUID      `db:"contributor_id" json:"contributor_id"`
	Title         string         `db:"title" json:"title"`
}

func (q *Queries) GetContributorPayments(ctx context.Context, contributorID uuid.UUID) ([]GetContributorPaymentsRow, error) {
	rows, err := q.db.Query(ctx, getContributorPayments, contributorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContributorPaymentsRow{}
	for rows.Next() {
		var i GetContributorPaymentsRow
		if err := rows.Scan(
			&i.ID,
			&i.PurchaseID,
			&i.Price,
			&i.Revenue,
			&i.CreatedAt,
			&i.IsVerified,
			&i.PaymentMethod,
			&i.AccountNumber,
			&i.BankName,
			&i.InvoiceSerial,
			&i.ContributorID,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContributorScoreStatistics = `-- name: GetContributorScoreStatistics :one
select 
  sum(py.revenue) as revenue, 
  count(p.*) as purchase_count, 
  (
  select count(*) from score 
    where contributor_id = $1::uuid
  ) as score_count
from purchase p
  inner join score s on p.score_id = s.id 
  inner join payment py on py.purchase_id = p.id
where p.is_verified = true 
  and s.contributor_id = $1::uuid
`

type GetContributorScoreStatisticsRow struct {
	Revenue       int64 `db:"revenue" json:"revenue"`
	PurchaseCount int64 `db:"purchase_count" json:"purchase_count"`
	ScoreCount    int64 `db:"score_count" json:"score_count"`
}

func (q *Queries) GetContributorScoreStatistics(ctx context.Context, contributorID uuid.UUID) (GetContributorScoreStatisticsRow, error) {
	row := q.db.QueryRow(ctx, getContributorScoreStatistics, contributorID)
	var i GetContributorScoreStatisticsRow
	err := row.Scan(&i.Revenue, &i.PurchaseCount, &i.ScoreCount)
	return i, err
}

const getUnverifiedContributors = `-- name: GetUnverifiedContributors :many
select id, is_verified, full_name, verified_at, phone_number, musical_background, education, experience, portofolio_link, created_at, updated_at, deleted_at from contributor as c
where c.is_verified = false
`

func (q *Queries) GetUnverifiedContributors(ctx context.Context) ([]Contributor, error) {
	rows, err := q.db.Query(ctx, getUnverifiedContributors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Contributor{}
	for rows.Next() {
		var i Contributor
		if err := rows.Scan(
			&i.ID,
			&i.IsVerified,
			&i.FullName,
			&i.VerifiedAt,
			&i.PhoneNumber,
			&i.MusicalBackground,
			&i.Education,
			&i.Experience,
			&i.PortofolioLink,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertContributorPaymentMethod = `-- name: UpsertContributorPaymentMethod :exec
insert into payment_method (method, account_number, contributor_id, bank_name)
values ($1, $2, $3::uuid, $4)
  on conflict (contributor_id)
do update set method = $1,
              account_number = $2,
              bank_name = $4,
              updated_at = now()
`

type UpsertContributorPaymentMethodParams struct {
	Method        string    `db:"method" json:"method"`
	AccountNumber string    `db:"account_number" json:"account_number"`
	ContributorID uuid.UUID `db:"contributor_id" json:"contributor_id"`
	BankName      string    `db:"bank_name" json:"bank_name"`
}

func (q *Queries) UpsertContributorPaymentMethod(ctx context.Context, arg UpsertContributorPaymentMethodParams) error {
	_, err := q.db.Exec(ctx, upsertContributorPaymentMethod,
		arg.Method,
		arg.AccountNumber,
		arg.ContributorID,
		arg.BankName,
	)
	return err
}

const verifyContributor = `-- name: VerifyContributor :exec
update contributor
set is_verified = true,
    verified_at = now()
where id = $1
`

func (q *Queries) VerifyContributor(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, verifyContributor, id)
	return err
}
