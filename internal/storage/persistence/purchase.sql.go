// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: purchase.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPurchase = `-- name: CreatePurchase :one
insert into purchase (account_id, score_id, price, title)
values ($1, $2, $3, $4)
returning id
`

type CreatePurchaseParams struct {
	AccountID uuid.UUID      `db:"account_id" json:"account_id"`
	ScoreID   uuid.UUID      `db:"score_id" json:"score_id"`
	Price     pgtype.Numeric `db:"price" json:"price"`
	Title     string         `db:"title" json:"title"`
}

func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createPurchase,
		arg.AccountID,
		arg.ScoreID,
		arg.Price,
		arg.Title,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getAllPurchases = `-- name: GetAllPurchases :many
select p.id, p.invoice_serial, p.account_id, p.score_id, p.price, p.title, p.payment_proof_url, p.paid_at, p.is_verified, p.verified_at, p.created_at, p.updated_at, p.deleted_at, c.full_name from purchase p
join contributor c on c.id = account_id
`

type GetAllPurchasesRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	InvoiceSerial   int32              `db:"invoice_serial" json:"invoice_serial"`
	AccountID       uuid.UUID          `db:"account_id" json:"account_id"`
	ScoreID         uuid.UUID          `db:"score_id" json:"score_id"`
	Price           pgtype.Numeric     `db:"price" json:"price"`
	Title           string             `db:"title" json:"title"`
	PaymentProofUrl pgtype.Text        `db:"payment_proof_url" json:"payment_proof_url"`
	PaidAt          pgtype.Timestamptz `db:"paid_at" json:"paid_at"`
	IsVerified      bool               `db:"is_verified" json:"is_verified"`
	VerifiedAt      pgtype.Timestamptz `db:"verified_at" json:"verified_at"`
	CreatedAt       time.Time          `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	FullName        string             `db:"full_name" json:"full_name"`
}

func (q *Queries) GetAllPurchases(ctx context.Context) ([]GetAllPurchasesRow, error) {
	rows, err := q.db.Query(ctx, getAllPurchases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllPurchasesRow{}
	for rows.Next() {
		var i GetAllPurchasesRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceSerial,
			&i.AccountID,
			&i.ScoreID,
			&i.Price,
			&i.Title,
			&i.PaymentProofUrl,
			&i.PaidAt,
			&i.IsVerified,
			&i.VerifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FullName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseByAccountAndScoreId = `-- name: GetPurchaseByAccountAndScoreId :one
select id, invoice_serial, account_id, score_id, price, title, payment_proof_url, paid_at, is_verified, verified_at, created_at, updated_at, deleted_at from purchase
where account_id = $1 and score_id = $2
`

type GetPurchaseByAccountAndScoreIdParams struct {
	AccountID uuid.UUID `db:"account_id" json:"account_id"`
	ScoreID   uuid.UUID `db:"score_id" json:"score_id"`
}

func (q *Queries) GetPurchaseByAccountAndScoreId(ctx context.Context, arg GetPurchaseByAccountAndScoreIdParams) (Purchase, error) {
	row := q.db.QueryRow(ctx, getPurchaseByAccountAndScoreId, arg.AccountID, arg.ScoreID)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.InvoiceSerial,
		&i.AccountID,
		&i.ScoreID,
		&i.Price,
		&i.Title,
		&i.PaymentProofUrl,
		&i.PaidAt,
		&i.IsVerified,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPurchaseById = `-- name: GetPurchaseById :one
select id, invoice_serial, account_id, score_id, price, title, payment_proof_url, paid_at, is_verified, verified_at, created_at, updated_at, deleted_at from purchase
where id = $1 and account_id = $2
`

type GetPurchaseByIdParams struct {
	ID        uuid.UUID `db:"id" json:"id"`
	AccountID uuid.UUID `db:"account_id" json:"account_id"`
}

func (q *Queries) GetPurchaseById(ctx context.Context, arg GetPurchaseByIdParams) (Purchase, error) {
	row := q.db.QueryRow(ctx, getPurchaseById, arg.ID, arg.AccountID)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.InvoiceSerial,
		&i.AccountID,
		&i.ScoreID,
		&i.Price,
		&i.Title,
		&i.PaymentProofUrl,
		&i.PaidAt,
		&i.IsVerified,
		&i.VerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getPurchasedScoreById = `-- name: GetPurchasedScoreById :one
select
    s.id,
    s.title,
    s.description,
    a.email,
    c.full_name,
    s.difficulty,
    s.content_type,
    s.pdf_url,
    s.pdf_image_urls,
    s.price,
    s.audio_url,
    s.is_verified
from score s
join contributor c on c.id = s.contributor_id
join account a on a.id = c.id
where s.id = $1 and s.is_verified = true
limit 1
`

type GetPurchasedScoreByIdRow struct {
	ID           uuid.UUID      `db:"id" json:"id"`
	Title        string         `db:"title" json:"title"`
	Description  pgtype.Text    `db:"description" json:"description"`
	Email        string         `db:"email" json:"email"`
	FullName     string         `db:"full_name" json:"full_name"`
	Difficulty   Difficulty     `db:"difficulty" json:"difficulty"`
	ContentType  ContentType    `db:"content_type" json:"content_type"`
	PdfUrl       string         `db:"pdf_url" json:"pdf_url"`
	PdfImageUrls []string       `db:"pdf_image_urls" json:"pdf_image_urls"`
	Price        pgtype.Numeric `db:"price" json:"price"`
	AudioUrl     string         `db:"audio_url" json:"audio_url"`
	IsVerified   bool           `db:"is_verified" json:"is_verified"`
}

func (q *Queries) GetPurchasedScoreById(ctx context.Context, scoreID uuid.UUID) (GetPurchasedScoreByIdRow, error) {
	row := q.db.QueryRow(ctx, getPurchasedScoreById, scoreID)
	var i GetPurchasedScoreByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Email,
		&i.FullName,
		&i.Difficulty,
		&i.ContentType,
		&i.PdfUrl,
		&i.PdfImageUrls,
		&i.Price,
		&i.AudioUrl,
		&i.IsVerified,
	)
	return i, err
}

const getPurchasesByAccountId = `-- name: GetPurchasesByAccountId :many
select id, invoice_serial, account_id, score_id, price, title, payment_proof_url, paid_at, is_verified, verified_at, created_at, updated_at, deleted_at from purchase
where account_id = $1
order by created_at desc
`

func (q *Queries) GetPurchasesByAccountId(ctx context.Context, accountID uuid.UUID) ([]Purchase, error) {
	rows, err := q.db.Query(ctx, getPurchasesByAccountId, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Purchase{}
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceSerial,
			&i.AccountID,
			&i.ScoreID,
			&i.Price,
			&i.Title,
			&i.PaymentProofUrl,
			&i.PaidAt,
			&i.IsVerified,
			&i.VerifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePurchaseProof = `-- name: UpdatePurchaseProof :exec
update purchase set 
payment_proof_url = $1, 
paid_at = now(), updated_at = now()
where id = $2 and account_id = $3
`

type UpdatePurchaseProofParams struct {
	PaymentProofUrl pgtype.Text `db:"payment_proof_url" json:"payment_proof_url"`
	ID              uuid.UUID   `db:"id" json:"id"`
	AccountID       uuid.UUID   `db:"account_id" json:"account_id"`
}

func (q *Queries) UpdatePurchaseProof(ctx context.Context, arg UpdatePurchaseProofParams) error {
	_, err := q.db.Exec(ctx, updatePurchaseProof, arg.PaymentProofUrl, arg.ID, arg.AccountID)
	return err
}

const verifyPurchase = `-- name: VerifyPurchase :exec
update purchase set
is_verified = true,
verified_at = now()
where id = $1
`

func (q *Queries) VerifyPurchase(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, verifyPurchase, id)
	return err
}
